A kovetkezo public native funkciok kellenek:

/* J->C:
 * Ezzel kered valaminek a vegrehajtasat (pl. kep kicsinyitese).
 * Bemeno parameter a param (pl. forras kep).
 * Sync=true eseten azonnal vegrehajtja, a hivo szal (te) addig blokkolva vagy -> visszateresi ertek az eredmeny (pl. elforgatott kep)
 * Sync=false eseten kesobb fogja vegrehajtani, visszater egy egyedi id-vel (lasd response).
 */
ByteArray request(ByteArray param, boolean sync);

/* C->J:
 * Aszinkron hivasok eredmenye (callback=akkor hivom meg, amikor vegeztem).
 * id: az aszinkron hivaskor kapott egyedi azonosito.
 * result: a kert feladat eredmenye.
 */
void response(ByteArray id, ByteArray result);

/* C->J:
 * Valamilyen eventem van, errol informallak, aztan csinalsz vele valamit, ha akarsz.
 */
void inform(ByteArray info);

//--- U.EZEK VISSZAFELE IS

/* C->J:
 * Valamilyen feldolgozast kerek toled (en hivom meg).
 * Sajna a szinkront meg nem tudom, hogy hogyan oldom meg.
 * id: egyedi azonosito (ha kesz az eredmeny, azt ezzel egyutt kell visszakuldeni, hogy konnyen parositani tudjam a kereseket es az eredmenyeiket.
 * param: parameterek.
 */
void question(ByteArray id, ByteArray param);

/* J->C:
 * Valasz a question-re, azaz itt adod vissza az eredmenyt.
 * id: a question-ben kapott id.
 * result: a feldolgozas eredmenye.
 */
void answer(ByteArray id, ByteArray result);

/* J->C:
 * Valami evented van, ezzel tudod elkuldeni.
 * Vagy csinalok vele valamit, vagy nem (erdemes kulon szalrol meghivni, ha vegtelen ciklusba botlunk, akkor se akadj meg (max. terminate).
 */
void notify(ByteArray info);

//--------------------------------------------------------------------------------------------

Altalaban elmondhato, hogy a bemeneti parameterek (param) valami fuggveny id-vel kezdodnek, a kimenetiek (result) meg hibakoddal. Az info nyilvan valami event id-vel.
A unique id amugy RFC4112 kodolasu tobb vallalat altal publikalt GUID/UUID. Szoval ilyen globally unique id vagy mi. Bizhatunk benne, hogy tenyleg egyedi.

Ha ezt az interfacet jonak latod, akkor mar csak a serializalas/deserializalason kell gondolkozni (az interface valtozatlan maradhat, max egy dll-t kell majd mellette cserelgetned). Persze funcid-ket, errcode-okat, eventid-ket ki kell talalni nyilvan, meg hogy milyen parametereket milyen sorrendben serializalunk (little endian vagy bigendian, stringeket hossz|karakterek vagy karakterek|0 modon kodolunk...).
Torekedni szeretnek a bovithetosegre, szoval valszeg lesz majd egy csomo verzioszam meg mittudomenmi...

Ja, ha a request-et szinkronban hivod, akkur u.azt kapod vissza, mint amit aszinkron eseten a responsban kapnal.
A masik iranyu szinkron/aszinkronitast nem tudom, hogy hogyan lehet biztositani. Lehet ezt is ket fuggvenyre kellene inkabb szadni parameterezes helyett ByteArray request_sync(param), ByteArray request_async(param) es akkor nalad is ByteArray question(param) es void question(id, param) kell.

Ennyi, kerem kapcsolja ki.

Ja, ez a sync param nincs kivezetve, de a magja megvan...
Legkozelebb valami logikat is moge teszek.